<!DOCTYPE html>
<html>
  <head>
    <title>MMEA User's Guide</title>
    <meta name="author" content="Lukas Turcani">

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400" rel="stylesheet">
    <style>

    *{
        background-color: rgb(250,250,250);
    }

    h1,h2,h3,h4,h5,h6, p, code{
        font-family: Roboto, sans-serif;
        text-align: left;
        margin-left: 25%;
        margin-right: 25%;
        font-size: 125%;
        word-spacing: 0.35em;
        line-height: 150%;
        display: inline-block;
    }

    h1{
        font-size: 200%;
    }

    code{
        background-color: rgb(210,210,210);
        border-radius: 20px;
        display: block;
        font-size: inherit;
        padding: 1%;
        margin: 0px;
        margin-top: 1%;
        margin-bottom: 1%;
        display: block;
        }

    code.whole_file{
        padding: 5%;
    }

    .value{
        background-color: rgb(230,230,230);
        font-weight: 300;
    }

    </style>

  </head>

  <body>
    <h1 id="introduction">Introduction</h1>
    <p>
      MMEA (<b>M</b>acro<b>M</b>olecular <b>E</b>volutionary <b>A</b>lgorithm) is
      a genetic algorithm (GA) for chemistry. It aims to be as general as
      possible, being suitable for all kinds of molecules. While it cannot support
      everything out of the box, it is designed to be easily extended. For notes
      on how to extend MMEA, see the developer's guide.
    </p>

    <h1 id="installing_mmea">Installing MMEA</h1>
    <p>
        Dunno yet.
    </p>

    <h1 id="input_files">Input Files</h1>
    <p>
      To run MMEA you need to use an input file. These contain all the details
      required to start a GA calculation. Among other things, this may include
      things like which fitness function you want to use, the number of
      generations MMEA should make and how big the population should be. Have
      a quick look at the example input file below, no need to understand
      anything just yet.<br>
      <code class="whole_file">
        ####################################################################<br>
        # Population initialization function.<br>
        ####################################################################<br>
<br>
        init_func; init_random_cages;<br>
        bb_db="/home/username/aldehydes_3f";<br>
        lk_db="/home/username/amines_2f";<br>
        topologies=[FourPlusSix, EightPlusTwelve]<br>
<br>
        ####################################################################<br>
        # Selection function for selecting the next generation.<br>
        ####################################################################<br>
<br>
        generational_select_func; stochastic_sampling; use_rank=True<br>
<br>
        ####################################################################<br>
        # Selection function for selecting parents.<br>
        ####################################################################<br>
<br>
        parent_select_func; crossover_roulette<br>
<br>
        ####################################################################<br>
        # Selection function for selecting molecules for mutation.<br>
        ####################################################################<br>
<br>
        mutant_select_func; stochastic_sampling; duplicates=True<br>
<br>
        ####################################################################<br>
        # Crossover function.<br>
        ####################################################################<br>
<br>
        crossover_func; bb_lk_exchange<br>
<br>
        ####################################################################<br>
        # Mutation function 1.<br>
        ####################################################################<br>
<br>
        mutation_func; similar_bb;<br>
        database="/home/username/aldehydes_3f"<br>
<br>
        ####################################################################<br>
        # Mutation function 2.<br>
        ####################################################################<br>
<br>
        mutation_func; similar_lk;<br>
        database="/home/username/amines_2f"<br>
<br>
        ####################################################################<br>
        # When carrying mutations, chance that a given mutation function will be used.<br>
        ####################################################################<br>
<br>
        mutation_weights=[1/2,1/2]<br>
<br>
        ####################################################################<br>
        # Optimization function.<br>
        ####################################################################<br>
<br>
        opt_func; macromodel_cage_opt;<br>
        macromodel_path="/home/username/program_files/schrodinger2016-3"<br>
<br>
        ####################################################################<br>
        # Fitness function.<br>
        ####################################################################<br>
<br>
        fitness_func; cage; target_cavity=8; coeffs=[1,1,5,0,0];<br>
        energy_params={"key":("macromodel", 16, "/home/username/schrodinger2016-3")}<br>
<br>
        ####################################################################<br>
        # Number of generations to create.<br>
        ####################################################################<br>
<br>
        num_generations=10<br>
<br>
        ####################################################################<br>
        # Number of mutation operations to perform each generation.<br>
        ####################################################################<br>
<br>
        num_mutations=10<br>
<br>
        ####################################################################<br>
        # Number of crossover operations to perform each generation.<br>
        ####################################################################<br>
<br>
        num_crossovers=15<br>
<br>
        ####################################################################<br>
        # Size of the population.<br>
        ####################################################################<br>
<br>
        pop_size=20<br>
      </code>

    <h2>Format and structure.</h2>
    <p>
        The input file consists of a sequence of commands. Each command defines
        a variable or function used by MMEA. If the command defines a function
        used by MMEA, it must also define any parameters necessary to use the
        function. It does not have to define any default initialized parameters,
        though it may if desired.
    </p><p>
        Commands can be written across multiple lines
        and terminate when the last parameter is defined. This means that
    <code>
          generational_select_func;<br>
          stochastic_sampling;<br>
          use_rank=True
    </code>
    and
    <code>
        mutant_select_func; stochastic_sampling; duplicates=True
    </code>
    define the same command.
    </p><p>
    Any lines consiting of only whitespace or begging with
    <span class="value">#</span> are ignored. This
    can be useful for separating the input file into sections or explaining what
    a command is doing. For example,
    <code>
        ####################################################################<br>
        # Selection function for selecting molecules for mutation.<br>
        ####################################################################<br>
<br>
        mutant_select_func; stochastic_sampling; duplicates=True
    </code></p>
    <p>
        There are two kinds of command in the input file. The first kind has the
        form
      <code>
            keyword; function_name; param1=val1; param2=val2; param3=val3
      </code>
        For example,
      <code>
            generational_select_func; stochastic_sampling; use_rank=True
      </code>
        This means that the keyword is
        <span class="value">generational_select_func</span>, the
        function name is <span class="value">stochastic_sampling</span>,
        parameter 1's name is <span class="value">use_rank</span> and its value
        is <span class="value">True</span>. As you can see, in this case
        there is only 1 parameter name-value pair. The words which
        make up the command are separated by a semicolon. Notice that last
        word of a command is not followed by one.
    </p><p>
        Commands with this format define functions used by MMEA. As a result,
        it is called the <b>function definition format</b>.
        The function will correspond to the
        various GA operations, such as crossover, mutation and selection, or to
        things like the fitness function or optimization function (which
        optimizes the geometry of molecules created by MMEA).
    </p><p>
        The keyword defines which GA operation the command describes. In the
        command above the keyword
        <span class="value">generational_select_func</span>
        signifies that the command defines which function is to be used for
        selecting members of the next generation. The keyword in the command
      <code>
        parent_select_func; crossover_roulette
      </code>
        is <span class="value">parent_select_func</span>, which signifies that
        the command defines the
        function used for selecting parents for crossover. A list of valid
        keywords is described in a following section.
    </p><p>
        The parameter <span class="value">function_name</span> immediately
        follows the keyword (not counting the semicolon of course). It is the name
        of the function which carries out the role defined by the keyword. In
        a GA there are many tools for the same job. For example, if you wanted to
        select members of the next generation you could select the 4 with the
        highest fitness. Alternatively, you could select 4 completely at random.
        In both cases you fulfill the same role and would therefore use the
        keyword
        <span class="value">generational_select_func</span> but you use different
        functions to do it, hence different values would go into the
        <span class="value">function_name</span> parameter.
    </p><p>
        Unsurprisingly, <span class="value">function_name</span> must correspond to
        the name of a function defined within MMEA. Not only that, but the
        function must also fulfill the role designated by the keyword. For
        example, if the keyword is
        <span class="value">generational_select_func</span> then
        <span class="value">fittest</span> and
        <span class="value">roulette</span> are both valid values.
        How MMEA can give you the names of and descriptions of valid functions
        is described later in this guide.
    </p><p>
        Coming back to the command outline,
        <code>
              keyword; function_name; param1=val1; param2=val2; param3=val3
        </code>
        there is one part which still needs to be discussed. The
        <span class="value">param</span> and
        <span class="value">val</span> fields. These form a tuple separated by
        <span class="value">=</span> and no space. Individual
        <span class="value">param=val</span> tuples are then sperated by
        semicolons and can be placed on individual lines.
    </p><p>
        As is relatively
        normal for
        functions, functions in MMEA take parameters. The names and number of
        parameters will vary depending on the function. Some may take none.
        Others may require you to input the values of some parameters and allow
         you to omit others. When a function has a parameter that
        it does not force you to define in the input file, it is <b> default
        initialized</b>. This means that if you don't define the parameter
        in the input file it defaults to some predetermined value. Once again,
        if you want to know the valid parameters for a given function, a
        description of how MMEA will give you this is given later.
    </p><p>
        Valid <span class="value">val</span> values depend on the parameter.
        These follow Python syntax. So if a parameter wants you to
        input some numerical value,
        <code>
            some_keyword; some_function_name; some_param=1.2
        </code>
        would be perfectly fine. On the other hand, if a parameter wanted a
        string,
        <code>
            some_keyword; some_function_name; some_param="this is a string"
        </code>
    </p><p>
        What if a numpy array is desired or some user-defined type buried deep
        within the source code?
        <code>
            some_keyword; some_function_name; some_param=np.array([12, 3, 4])
        </code>
        and
        <code>
            some_keyword; some_function_name; some_param=SomeUsrType(12.1, "asd")
        </code>
        would both work! As long as the parameter says it needs a give type,
        you can safely enter it, as long as you stick to Python syntax. Note
        that the order in which you give the parameter-value tuples does not
        matter.
    </p><p>
        All keywords should be defined in the input file once. The exception to
        this is <span class="value">mutation_func</span>. It is quite possible
        that during a GA run the
        user wishes to use multiple mutation operations. As a result it is
        perfectly reasonable to include multiple commands with the keyword
        <span class="value">mutation_func</span>. When this is done, the user
        must also include the line
      <code>
        mutation_weights=[0.1, 0.45, 0.45]
      </code>
        This line tells MMEA that when a mutation is to be performed it should
        select the first mutation function defined in the input file with a 0.1
        probability and the second and third mutation functions defined in the
        input file with a 0.45 probability. The probabilities can of course be
        modified by the user. The only requirements are that the probabilities
        sum to 1 and that the number of elements in the list and the number of
        mutation functions defined in the input file is the same.
    </p><p>
        There is a second kind of non-comment line in the input file of MMEA.
        These lines have the form
      <code>
        keyword=val
      </code>
        As you can see, these are much simpler. They define basic constants
        relevant to the GA. As a result, this is called the <b>constant
        definition format</b>. This includes things like population size, number
        of crossover operations carried out during each generation and so on. It
        is merely the keyword, a <span class="value">=</span> and the value. No
        spaces, no semicolons.
    </p>
    <h2>Valid input values.</h2>
    <p>
        In order to prevent the need to continuously update this documentation
        when a new function is added to MMEA, only valid keywords are described
        here. However, this does not mean a user has to go into the source code
        to find out what functions they have at their disposal. This section
        also describes how MMEA can be made to output valid function names and
        parameters for each keyword.
    </p>
    <h3>List and explanation of valid keywords.</h3>

    <p>
        The keywords are given here with the following format<br><br>
        <span class="value">keyword</span> - <b>line format</b> - <i>excluded_param1</i>, <i>excluded_param2</i> - Explantion of keyword.<br><br>
        Excluded parameters are those that the function documentation may state
        as required, but which do not need to be provided in the input file.
    </p><p>

The keywords are:<br><br>
<span class="value">init_func</span> - <b>function definition format</b> - <i>ga_tools</i> - The function used to create the initial population.<br><br>
<span class="value">generational_select_func</span> - <b>function definition format</b> -  <i>population</i> - The function used to select members of the next generation.<br><br>
<span class="value">parent_select_func</span> - <b>function definition format</b> -  <i>population</i>  - The function used to select parents for crossover.<br><br>
<span class="value">mutant_select_func</span> - <b>function definition format</b> -  <i>population</i>  - The function used to select individuals for mutation.<br><br>
<span class="value">crossover_func</span>  - <b>function definition format</b> -  <i>marco_mol1</i> , <i>macro_mol2</i>  - The function which carries out the crossover operation.<br><br>
<span class="value">mutation_func</span>  - <b>function definition format</b> -  <i>macro_mol</i>  - The function which carries out the mutation operation.<br><br>
<span class="value">opt_func</span>  - <b>function definition format</b> -  <i>macro_mol</i>  - The function which optimizes the geometry of the molecules.<br><br>
<span class="value">fitness_func</span>  - <b>function definition format</b> -  <i>macro_mol</i>  - The function which calculates fitness.<br><br>
<span class="value">normalization_func</span>  - <b>function definition format</b> -  <i>population</i>  - The function which normalizes fitness values. This keyword is optional.<br><br>
<span class="value">num_generations</span>  - <b>constant definition format</b> - The number of generations which MMEA will create.<br><br>
<span class="value">num_mutations</span>  - <b>constant definition format</b> - The number of mutations MMEA will carry out each generation.<br><br>
<span class="value">num_crossovers</span>  - <b>constant definition format</b> - The number of crossover operations MMEA will carry out each generation.<br><br>
<span class="value">pop_size</span>  - <b>constant definition format</b> - The size of the population.<br><br>
<span class="value">mutation_weights</span>  - <b>constant definition format</b> - The probability with which each mutation function defined in the input
file will be used when a mutation operation is performed. Note that the form of this constant is a list. For example<br><br>
    <code>
        mutation_weights=[0.1, 0.45, 0.45]
    </code>
</p>
    <h3>Finding available functions and their arguments.</h3>

    <p>
        In order to find out what functions MMEA offers for a given keyword,
        using the console go into the directory containing MMEA.<br>
        Run the command
    <code>
        python -m MMEA -h keyword
    </code>
        where <span class="value">keyword</span> is one of the valid keywords defined
        in the previous section or <span class="value">energy</span> or
        <span class="value">topologies</span>. <span class="value">energy</span>
        lists the functions available for energy
        calculations while the <span class="value">topology</span> lists the
        macromolecules MMEA can construct. These values are often used as
        parameters in functions.
    </p>

    <p>
        MMEA will then output a list of valid functions, their description, and
        a list of their parameters.
    </p>

    <p>
        In this example, the keyword <span class="value">crossover_func</span> was
        used and the only
        available function was <span class="value">bb_lk_exchange</span>. Other
        keywords will have more
        options available (and more may be added to this one). As you can see
        the only parameters the function takes are
        <span class="value">macro_mol1</span> and <span class="value">macro_mol2</span>.
        As these are handled automatically by MMEA (Recall the previous
        section) no parameters should be provided in the input
        file. A valid line would look like
      <code>
        crossover_func; bb_lk_exchange$
      </code>
  </p>

    <h2>Example</h2>

    <p>
        Here is an example input file followed by a line by line explanation of
        what it's doing.

    <code class="whole_file">
##################################################################################
# Population initialization function.
##################################################################################

init_func; init_random_cages;
bb_db="/home/username/aldehydes_3f";
lk_db="/home/username/amines_2f";
topologies=[FourPlusSix, EightPlusTwelve]$

##################################################################################
# Selection function for selecting the next generation.
##################################################################################

generational_select_func; stochastic_sampling; use_rank=True$

##################################################################################
# Selection function for selecting parents.
##################################################################################

parent_select_func; crossover_roulette$

##################################################################################
# Selection function for selecting molecules for mutation.
##################################################################################

mutant_select_func; stochastic_sampling; duplicates=True$

##################################################################################
# Crossover function.
##################################################################################

crossover_func; bb_lk_exchange$

##################################################################################
# Mutation function 1.
##################################################################################

mutation_func; similar_bb;
database="/home/username/aldehydes_3f"$

##################################################################################
# Mutation function 2.
##################################################################################

mutation_func; similar_lk;
database="/home/username/amines_2f"$

##################################################################################
# When carrying mutations, chance that a given mutation function will be used.
##################################################################################

mutation_weights=[1/2,1/2]$

##################################################################################
# Optimization function.
##################################################################################

opt_func; macromodel_cage_opt;
macromodel_path="/home/username/program_files/schrodinger2016-3"$

##################################################################################
# Fitness function.
##################################################################################

fitness_func; cage; target_cavity=8; coeffs=[1,1,5,0,0];
energy_params={"key":("macromodel", 16, "/home/username/schrodinger2016-3")}$

##################################################################################
# Number of generations to create.
##################################################################################

num_generations=10$

##################################################################################
# Number of mutation operations to perform each generation.
##################################################################################

num_mutations=10$

##################################################################################
# Number of crossover operations to perform each generation.
##################################################################################

num_crossovers=15$

##################################################################################
# Size of the population.
##################################################################################

pop_size=20$
    </code>
    <p>
        The first command runs from line 5 to 8. It has the keyword
        ``init\_func", which  means that it defines the initialization function
        for the GA population. The
        initialization function is called ``init\_random\_cages". This function
        creates
        a population consisting of randomly assembled ``cage" molecules. The
         function
        takes the parameter ``bb\_db" which receives a string. The string is the
        path of
        a directory which holds monomers used for constructing the cages. The
        parameter
        ``lk\_db" has the same role. The parameter ``topologies" requires an
        array or
        list. The list contains the names of cage topologies defined within
        MMEA.
    </p><p>
        The second command is on line 14. The keyword
        ``generational\_select\_func" indicates that the command defines the
        selection function used for selecting the next generation.
    </p>

    <h1>Running MMEA</h1>
    <h2>From the command line.</h2>
    <h1>Output</h1>
    <h1>MMEA as a Library</h1>
  </body>
</html>
