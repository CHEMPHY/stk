<!DOCTYPE html>
<html>
  <head>
    <title>MMEA User's Guide</title>
    <meta name="author" content="Lukas Turcani">

    <!--link href="https://fonts.googleapis.com/css?family=Roboto:300,400" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Ubuntu+Mono" /-->

    <style>

    *{
        background-color: rgb(250,250,250);
    }

    h1,h2,h3,h4,h5,h6, p, code, pre{
        font-family: Roboto, sans-serif;
        text-align: left;
        margin-left: 25%;
        margin-right: 25%;
        font-size: 125%;
        word-spacing: 0.35em;
        line-height: 150%;
        display: inline-block;
    }

    h1{
        font-size: 200%;
    }

    code{
        background-color: rgb(210,210,210);
        border-radius: 20px;
        display: block;
        font-size: inherit;
        padding: 1%;
        margin: 0px;
        margin-top: 1%;
        margin-bottom: 1%;
        display: block;
        }

    pre {
        background-color: rgb(210,210,210);
        border-radius: 20px;
        padding: 1%;
        display: block;
    }

    .c1, .n, .o, .mi, .s1, .p, .bp, .mf{
        background-color: rgb(210, 210, 210);
    }

    .s1 {
        color: green;
    }

    .c1 {
        color: gray;
        font-style: italic;
    }

    .bp, .mi, .mf {
        color: red;
    }

    .value{
        background-color: rgb(230,230,230);
        font-weight: 300;
    }

    .mmea_output{
        font-family: "Ubuntu Mono";
    }


    p.wide{
        display: block;
    }


    </style>

  </head>

  <body>
    <h1 id="introduction">Introduction</h1>
    <p>
      MMEA (<b>M</b>acro<b>M</b>olecular <b>E</b>volutionary <b>A</b>lgorithm) is
      a genetic algorithm (GA) for chemistry. It aims to be as general as
      possible, being suitable for all kinds of molecules. While it cannot support
      everything out of the box, it is designed to be easily extended. For notes
      on how to extend MMEA, see the developer's guide.
    </p>

    <h1 id="installing_mmea">Installing MMEA</h1>
    <p>
        Dunno yet.
    </p>

    <h1 id="input_files">Input Files</h1>
    <p>
      To run MMEA you need to use an input file. These contain all the details
      required to start a GA calculation. Among other things, this may include
      things like which fitness function you want to use, the number of
      generations MMEA should make and how big the population should be. Have
      a quick look at the example input file below, no need to understand
      anything just yet.<br>


<div class="highlight"><pre><span></span><span class="c1">#############################################################</span>
<span class="c1"># Define basic GA constants.</span>
<span class="c1">#############################################################</span>

<span class="n">num_generations</span> <span class="o">=</span> <span class="mi">250</span>

<span class="c1"># Number of mutation operations to perform each generation.</span>
<span class="n">num_mutations</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Number of crossover operations to perform each generation.</span>
<span class="n">num_crossovers</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Size of the population.</span>
<span class="n">pop_size</span> <span class="o">=</span> <span class="mi">25</span>

<span class="c1">#############################################################</span>
<span class="c1"># Define variables.</span>
<span class="c1">#############################################################</span>

<span class="n">monomer_database</span> <span class="o">=</span> <span class="s1">&#39;/path/to/monomer/database&#39;</span>
<span class="n">polymer_db1</span> <span class="o">=</span> <span class="s1">&#39;path/to/previously/made/polymers1.json&#39;</span>
<span class="n">polymer_db2</span> <span class="o">=</span> <span class="s1">&#39;/path/to/previously/made/polymers2.json&#39;</span>

<span class="c1">#############################################################</span>
<span class="c1"># Databases of stored molecules to use.</span>
<span class="c1">#############################################################</span>

<span class="n">databases</span> <span class="o">=</span> <span class="p">[</span><span class="n">polymer_db1</span><span class="p">,</span> <span class="n">polymer_db1</span><span class="p">]</span>

<span class="c1">#############################################################</span>
<span class="c1"># Population initialization function.</span>
<span class="c1">#############################################################</span>

<span class="n">init_func</span> <span class="o">=</span>  <span class="p">{</span>

            <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;init_random_polymers&#39;</span><span class="p">,</span>
            <span class="s1">&#39;monomer_db&#39;</span> <span class="p">:</span> <span class="n">monomer_database</span><span class="p">,</span>
            <span class="s1">&#39;topologies&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">24</span><span class="p">),</span>
                            <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;ABBC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">12</span><span class="p">)]</span>
          <span class="p">}</span>

<span class="c1">#############################################################</span>
<span class="c1"># Selection function for selecting the next generation.</span>
<span class="c1">#############################################################</span>

<span class="n">generational_select_func</span> <span class="o">=</span>  <span class="p">{</span>
                           <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;stochastic_sampling&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;use_rank&#39;</span> <span class="p">:</span> <span class="bp">True</span>
                          <span class="p">}</span>

<span class="c1">#############################################################</span>
<span class="c1"># Selection function for selecting parents.</span>
<span class="c1">#############################################################</span>

<span class="n">parent_select_func</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;NAME&#39;</span> <span class="p">:</span><span class="s1">&#39;crossover_roulette&#39;</span><span class="p">}</span>

<span class="c1">#############################################################</span>
<span class="c1"># Selection function for selecting molecules for mutation.</span>
<span class="c1">#############################################################</span>

<span class="n">mutant_select_func</span> <span class="o">=</span>  <span class="p">{</span>
                     <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;stochastic_sampling&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;duplicates&#39;</span><span class="p">:</span><span class="bp">True</span>
                    <span class="p">}</span>

<span class="c1">#############################################################</span>
<span class="c1"># Crossover functions.</span>
<span class="c1">#############################################################</span>

<span class="c1"># Crossover function 1.</span>
<span class="n">crossover_func1</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;polymer_monomer_shuffle&#39;</span><span class="p">}</span>

<span class="c1"># Crossover function 2.</span>
<span class="n">crossover_func2</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;polymer_topology_shuffle&#39;</span><span class="p">}</span>

<span class="c1"># Tell MMEA which crossover functions to use.</span>
<span class="n">crossover_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">crossover_func1</span><span class="p">,</span> <span class="n">crossover_func2</span><span class="p">]</span>

<span class="c1"># Probability that each crossover function is selected.</span>
<span class="n">crossover_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]</span>

<span class="c1">#############################################################</span>
<span class="c1"># Mutation functions</span>
<span class="c1">#############################################################</span>

<span class="c1"># Mutation function 1.</span>
<span class="n">mutation_func1</span> <span class="o">=</span>  <span class="p">{</span>
                 <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;cage_random_bb&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;database&#39;</span> <span class="p">:</span> <span class="n">bb_db_path</span>
                <span class="p">}</span>

<span class="c1"># Mutation function 2.</span>
<span class="n">mutation_func2</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;cage_random_lk&#39;</span><span class="p">,</span>
                <span class="s1">&#39;database&#39;</span> <span class="p">:</span> <span class="n">lk_db_path</span>
               <span class="p">}</span>

<span class="c1"># Tell MMEA which mutation functions to use.</span>
<span class="n">mutation_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mutation_func1</span><span class="p">,</span> <span class="n">mutation_func2</span><span class="p">]</span>

<span class="c1"># Probability that each mutation function is selected.</span>
<span class="n">mutation_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>

<span class="c1">#############################################################</span>
<span class="c1"># Optimization function.</span>
<span class="c1">#############################################################</span>

<span class="n">opt_func</span> <span class="o">=</span>  <span class="p">{</span>
            <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;rdkit_optimization&#39;</span><span class="p">,</span>
            <span class="s1">&#39;embed&#39;</span> <span class="p">:</span> <span class="bp">True</span>
          <span class="p">}</span>

<span class="c1">#############################################################</span>
<span class="c1"># Fitness function.</span>
<span class="c1">#############################################################</span>

<span class="c1"># Calculates the polymer&#39;s energy and surface area.</span>
<span class="n">fitness_func</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;polymer_E_and_SA&#39;</span><span class="p">}</span>

<span class="c1">#############################################################</span>
<span class="c1"># Normalization functions.</span>
<span class="c1">#############################################################</span>

<span class="c1"># First shift all energy values so that they are always positive.</span>
<span class="n">norm_func1</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;shift_elements&#39;</span><span class="p">,</span>
            <span class="s1">&#39;indices&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
           <span class="p">}</span>

<span class="c1"># Second, make sure that the magnitudes of all fitness parameters</span>
<span class="c1"># are comparable.</span>
<span class="n">norm_func2</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;magnitudes&#39;</span><span class="p">}</span>

<span class="c1"># Combine the fitness parameters into a single fitness value.</span>
<span class="n">norm_func3</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;combine&#39;</span><span class="p">,</span>
            <span class="s1">&#39;coefficients&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
            <span class="s1">&#39;exponents&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
           <span class="p">}</span>

<span class="n">normalization_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm_func1</span><span class="p">,</span> <span class="n">norm_func2</span><span class="p">,</span> <span class="n">norm_func3</span><span class="p">]</span>
</pre></div>

    <h2>Format and structure.</h2>
    <p>
        An MMEA input file is a Python script. To be a valid input file, the
        script must define a number of variables. These variables define
        various functions or constants which are used by the GA. The script
        is run by MMEA so any valid Python construct can be used. For
        example the use of loops or iteraters to construct input parameters
        is completely valid. Modules can be imported as well. The namespace
        of MMEA is valid within the input file without the need of additional
        import statements.
    </p><p>
        The variables which an input script must define are listed in the
        section below, along with what an explantation of the variable and the
        data type it must hold. The script can define any number of variables
        but the ones listed in the following section have a meaning within
        MMEA, while any others are ignored. However definition of
        additional variables is useful for making an input file maintainable
        and readable.
    </p><p>
        There are two main categories of variable.
        One which holds simple constants such as numbers, strings or lists.
        These usually correspond to constants the GA uses, such as population
        size. The other type of variable holds information on functions which the
        GA must use. These are defined via a dictionary.
        <pre><span class="n">generational_select_func</span> <span class="o">=</span>  <span class="p">{</span>
                       <span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;stochastic_sampling&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;use_rank&#39;</span> <span class="p">:</span> <span class="bp">True</span>
                      <span class="p">}</span></pre>
    </p><p>
        The dictionary always has a key <span class="value s1">'NAME'</span>. The value
        this key holds is the name of the function used to perform a given role.
        The variable name itself defines the role. In the example above
        <span class="value">generational_select_func</span> indicates that
        the function which selects population members for the next generation
        is being defined. The key - value pair
        <span class="value s1">'NAME'</span><span class="value"> : </span><span class="value s1">'stochastic_sampling'</span>
        indicates that the stochastic sampling function used to carry out this role.
    </p><p>
        In
        <pre><span class="n">fitness_func</span> <span class="o">=</span>  <span class="p">{</span><span class="s1">&#39;NAME&#39;</span> <span class="p">:</span> <span class="s1">&#39;polymer_E_and_SA&#39;</span><span class="p">}</span></pre>
    </p><p>
        The role is given by <span class="value">fitness_func</span> which
        indicates that the fitness function is being defined.
        <span class="value s1">'NAME'</span><span class="value"> : </span><span class="value s1">'polymer_E_and_SA'</span>
        indicates that the function <span class="value s1">'polymer_E_and_SA'</span>
        is used to calculate the fitness.
    </p><p>
        The dictionary also defines any parameters that the function needs. These
        are given as key - value pairs. If a function takes optional
        parameters they maybe be ommited from the diciontary, in which
        case they will be default initialized.
    </p>


    <h2>Constructing input files.</h2>
    <p>
        To build an input file you need to know that names of all variables
        which need to be defined for MMEA to launch a GA run. You also need
        to know what data type the variable must hold. For variables which
        define functions, you need to know which functions can be paired with
        a given variable. For example you can't put the name of a
        fitness or mutation function when defining
        <span class="value">generational_select_func</span>.
    </p><p>
        One way to make all of this information available is to list it all
        in this documentation. This is problematic because it would require
        updating it each time a new function is added to MMEA. Instead,
        only the names of variables which need to be defined are given.
        An explantion of the role of the variable and the data type it
        must hold is also provided.
    </p><p>
        A guide on how to figure out which functions can be paired with which
        variable, and what parameters each function requires, is
        given in section below.
    </p>

    <h3>Finding available functions and their arguments.</h3>

    <p>
        In order to find out what functions can be used
        for a given variable,
        using the console go into the directory containing MMEA. Run the command
    <code class="mmea_output">
        python -m MMEA -h variable_name
    </code>
        where <span class="value">variable_name</span> is one of the name of a
        variable defined
        in the following section or <span class="value">energy</span> or
        <span class="value">topologies</span>. <span class="value">energy</span>
        lists the functions available for energy
        calculations while the <span class="value">topologies</span> lists the
        macromolecules MMEA can construct. These values are often used as
        parameters in functions.
    </p><p>
        Let's see an example,
        <code class="mmea_output">
            python -m MMEA -h mutation_funcs
        </code>
        MMEA will then output a list of valid functions, their description, and
        a list of their parameters.
        <code class="mmea_output">
            cage_random_bb<br>
            --------------<br>
<br>
                    &emsp;Substitutes a building-block* with a random one from a database.<br>
<br>
                    &emsp;Parameters<br>
                    &emsp;----------<br>
                &emsp;&emsp;macro_mol : Cage<br>
                        &emsp;&emsp;&emsp;The cage who's building-block* will be exchanged. Note that<br>
                        &emsp;&emsp;&emsp;the cage is not destroyed. It is used a template for a new<br>
                        &emsp;&emsp;&emsp;cage.<br>
<br>
                    &emsp;&emsp;database : str<br>
                        &emsp;&emsp;&emsp;The full path of the database from which a new<br>
                    &emsp;&emsp;&emsp;building-block* is to be found.<br>
<br>
                    &emsp;Returns<br>
                &emsp;-------<br>
                    &emsp;&emsp;Cage<br>
                        &emsp;&emsp;&emsp;A cage instance generated by taking all attributes of<br>
                        &emsp;&emsp;&emsp;`macro_mol` except its building-block* which is replaced by<br>
                        &emsp;&emsp;&emsp;a random building-block* from `database`.<br>
<br>
<br>
            random_cage_topology<br>
            --------------------<br>
<br>
                    &emsp;Changes `macro_mol` topology to a random one from `topologies`.<br>
<br>
                    &emsp;Parameters<br>
                    &emsp;----------<br>
                    &emsp;&emsp;macro_mol : Cage<br>
                        &emsp;&emsp;&emsp;The cage which is to be mutated.<br>
<br>
                    &emsp;&emsp;topologies : list of CageTopology instances<br>
                        &emsp;&emsp;&emsp;This lists holds the topology classes from which one is<br>
                        &emsp;&emsp;&emsp;selected at random to form a new cage. If the `macro_mol`<br>
                        &emsp;&emsp;&emsp;has a topology found in `topologies` that topology will not<br>
                        &emsp;&emsp;&emsp;be selected.<br>
<br>
                    &emsp;Returns<br>
                    &emsp;-------<br>
                    &emsp;&emsp;Cage<br>
                        &emsp;&emsp;&emsp;A cage generated by initializing a new ``Cage`` instance<br>
                        &emsp;&emsp;&emsp;with all the same paramters as `macro_mol` except for the<br>
                        &emsp;&emsp;&emsp;topology.<br>
<br>
<br>
            cage_similar_bb<br>
            ---------------<br>
<br>
                    &emsp;Substitute the building-block* with similar one from `database`.<br>
<br>
                    &emsp;All of the molecules in `database` are checked for similarity to<br>
                    &emsp;the building-block* of `macro_mol`. The first time this mutation<br>
                    &emsp;function is run on a cage, the most similar molecule in<br>
                    &emsp;`database` is used to substitute the building-block*. The next<br>
                    &emsp;time this mutation function is run on the same cage, the second<br>
                    &emsp;most similar molecule from `database` is used and so on.<br>
<br>
                    &emsp;Parameters<br>
                    &emsp;----------<br>
                    &emsp;&emsp;macro_mol : Cage<br>
                        &emsp;&emsp;&emsp;The cage which is to have its building-block* substituted.<br>
<br>
                    &emsp;&emsp;database : str<br>
                        &emsp;&emsp;&emsp;The full path of the database from which molecules are used<br>
                        &emsp;&emsp;&emsp;to substitute the building-block* of `macro_mol`.<br>
<br>
                    &emsp;Modifies<br>
                    &emsp;--------<br>
                    &emsp;&emsp;macro_mol._similar_bb_mols : generator<br>
                        &emsp;&emsp;&emsp;Creates this attribute on the `macro_mol` instance. This<br>
                        &emsp;&emsp;&emsp;allows the function to keep track of which molecule from<br>
                        &emsp;&emsp;&emsp;`database` should be used in the substitution.<br>
<br>
                    &emsp;Returns<br>
                    &emsp;-------<br>
                    &emsp;&emsp;Cage<br>
                        &emsp;&emsp;&emsp;A new cage with the same linker as `macro_mol` but a<br>
                        &emsp;&emsp;&emsp;different building-block*. The building-block* is selected<br>
                        &emsp;&emsp;&emsp;according to the description in this docstring.<br>
<br>
<br>
            cage_similar_lk<br>
            ---------------<br>
<br>
                    &emsp;Substitute the linker with a similar one from `database`.<br>
<br>
                    &emsp;All of the molecules in `database` are checked for similarity to<br>
                    &emsp;the linker of `macro_mol`. The first time this mutation function<br>
                    &emsp;is run on a cage, the most similar molecule in `database` is<br>
                    &emsp;used to substitute the linker. The next time this mutation<br>
                    &emsp;function is run on the same cage, the second most similar<br>
                    &emsp;molecule from `database` is used and so on.<br>
<br>
                    &emsp;Parameters<br>
                    &emsp;----------<br>
                    &emsp;&emsp;macro_mol : Cage<br>
                        &emsp;&emsp;&emsp;The cage which is to have its linker substituted.<br>
<br>
                    &emsp;&emsp;database : str<br>
                        &emsp;&emsp;&emsp;The full path of the database from which molecules are used<br>
                        &emsp;&emsp;&emsp;to substitute the linker of `macro_mol`.<br>
<br>
                    &emsp;Modifies<br>
                    &emsp;--------<br>
                    &emsp;&emsp;macro_mol._similar_lk_mols : generator<br>
                        &emsp;&emsp;&emsp;Creates this attribute on the `macro_mol` instance. This<br>
                        &emsp;&emsp;&emsp;allows the function to keep track of which molecule from<br>
                        &emsp;&emsp;&emsp;`database` should be used in the substitution.<br>
<br>
                    &emsp;Returns<br>
                    &emsp;-------<br>
                    &emsp;&emsp;Cage<br>
                        &emsp;&emsp;&emsp;A new cage with the same building-block* as `macro_mol` but<br>
                        &emsp;&emsp;&emsp;a different linker. The linker is selected according to the<br>
                        &emsp;&emsp;&emsp;description in this docstring.<br>
<br>
<br>
            cage_random_lk<br>
            --------------<br>
<br>
                    &emsp;Substitutes a linker with a random one from a database.<br>
<br>
                    &emsp;Parameters<br>
                    &emsp;----------<br>
                    &emsp;&emsp;macro_mol : Cage<br>
                        &emsp;&emsp;&emsp;The cage who's linker will be exchanged. Note that<br>
                        &emsp;&emsp;&emsp;the cage is not destroyed. It is used a template for a new<br>
                        &emsp;&emsp;&emsp;cage.<br>
<br>
                    &emsp;&emsp;database : str<br>
                        &emsp;&emsp;&emsp;The full path of the database from which a new linker is to<br>
                        &emsp;&emsp;&emsp;be found.<br>
<br>
                    &emsp;Returns<br>
                    &emsp;-------<br>
                    &emsp;&emsp;Cage<br>
                        &emsp;&emsp;&emsp;A cage instance generated by taking all attributes of<br>
                        &emsp;&emsp;&emsp;`macro_mol` except its linker which is replaced by a random<br>
                        &emsp;&emsp;&emsp;linker from `database`.<br>
        </code>

    </p>

    <p>
        In this example, the variable <span class="value">mutation_funcs</span> was
        used. Now we can select one of the mutation functions MMEA supports and
        add it to the list  <span class="value">mutation_funcs</span>.
<pre>
m1 = { <span class="s1">'NAME'</span> : <span class="s1">cage_similar_lk</span>,
        <span class="s1">'database'</span> : <span class="s1">'some/data/base/path'</span>
      }
mutation_funcs = [m1]</pre>


  </p>

    <h3>List and explanation of required variables.</h3>

    <p>
        The variables are given here with the following format<br><br>
        <span class="value">variable_name</span> - <b>data type</b> - <i>excluded_param1</i>, <i>excluded_param2</i> -
        Explanation of variable role.<br><br>
        Excluded parameters are those that the function documentation may state
        as required, but which do not need to be provided in the input file.
    </p><p>

The keywords are:<br><br>
<span class="value">init_func</span> - <b>dictionary</b> - <i>ga_tools</i> - The function used to create the initial population.<br><br>
<span class="value">generational_select_func</span> - <b>dictionary</b> -  <i>population</i> - The function used to select members of the next generation.<br><br>
<span class="value">parent_select_func</span> - <b>dictionary</b> -  <i>population</i>  - The function used to select parents for crossover.<br><br>
<span class="value">mutant_select_func</span> - <b>dictionary</b> -  <i>population</i>  - The function used to select individuals for mutation.<br><br>
<span class="value">crossover_funcs</span>  - <b>list of dictionaries</b> -  <i>marco_mol1</i> , <i>macro_mol2</i>  -
Each dictionary represents a funciton used for crossover.<br><br>
<span class="value">mutation_funcs</span>  - <b>list of dictionaries</b> -  <i>macro_mol</i>  -
Each dictionary represents a funciton used for mutation.<br><br>
<span class="value">opt_func</span>  - <b>dictionary</b> -  <i>macro_mol</i>  - The function which optimizes the geometry of the molecules.<br><br>
<span class="value">fitness_func</span>  - <b>dictionary</b> -  <i>macro_mol</i>  - The function which calculates fitness. Some
fitness functions may calculate a list of fitness parameters which are then transformed and combined into a single
fitness value by normalization functions.<br><br>
<span class="value">normalization_funcs</span>  - <b>list of dictionaries</b> -  <i>population</i>  -
Each dictionary represents a normalization function. Each normalization function is applied every
genertion, in the order in which they are given in this list. This variable is optional,
assuming that the fitness function returns a number.<br><br>
<span class="value">exit_func</span>  - <b>dictionary</b> - <i>population</i> -
This is an optional variable. It defines a function which causes the GA to stop before all generations have been made.
For example, once a given fittness has been reached or a certian molecule has been made.<br><br>
<span class="value">num_generations</span>  - <b>int</b> - The number of generations which MMEA will create.<br><br>
<span class="value">num_mutations</span>  - <b>int</b> - The number of mutations MMEA will carry out each generation.<br><br>
<span class="value">num_crossovers</span>  - <b>int</b> - The number of crossover operations MMEA will carry out each generation.<br><br>
<span class="value">pop_size</span>  - <b>int</b> - The size of the population.<br><br>
<span class="value">parallel</span>  - <b>bool</b> - An optional variable, it's default value is <span class="value">True</span>.
It toggles whether optimization and fitness calculation of molecules is done in parallel.<br><br>
<span class="value">databases</span>  - <b>list of strings</b> - This is an optional variable. Each string is the full path to a .json file
holding an MMEA database of molecules. The molecules in each database
 are loaded into MMEA's memory when the GA is started. As a result, they do not have to be
reoptimized or have fitness values recalculated during the GA.  This can dramatically improve MMEA's
performance. The .json files are generated by MMEA after each run and can also be
made manually. See the <b>Working with databases.</b> section.<br><br>
<span class="value">mutation_weights</span>  - <b>list of floats</b> - The probability with which each mutation function defined in
<span class="value">mutation_funcs</span> will be used when a mutation operation is performed.
The order of the probabilities corresponds to the order in which
the mutations functions are given in <span class="value">mutation_funcs</span>.<br><br>
<span class="value">crossover_weights</span>  - <b>list of floats</b> - The probability with which each mutation function defined in
<span class="value">crossover_funcs</span> will be used when a crossover operation is performed.
The order of the probabilities corresponds to the order in which
the crossover functions are given in <span class="value">crossover_funcs</span>.<br><br>
</p>


    <h2>Example</h2>

    <p class="wide">
        Here is an example input file followed by a line by line explanation of
        what it's doing.

    <code class="whole_file">
###################################################################<br>
# Population initialization function.<br>
###################################################################<br>
<br>
init_func; init_random_cages;<br>
bb_db="/home/username/aldehydes_3f";<br>
lk_db="/home/username/amines_2f";<br>
topologies=[FourPlusSix, EightPlusTwelve]<br>
<br>
###################################################################<br>
# Selection function for selecting the next generation.<br>
###################################################################<br>
<br>
generational_select_func; stochastic_sampling; use_rank=True<br>
<br>
###################################################################<br>
# Selection function for selecting parents.<br>
###################################################################<br>
<br>
parent_select_func; crossover_roulette<br>
<br>
###################################################################<br>
# Selection function for selecting molecules for mutation.<br>
###################################################################<br>
<br>
mutant_select_func; stochastic_sampling; duplicates=True<br>
<br>
###################################################################<br>
# Crossover function.<br>
###################################################################<br>
<br>
crossover_func; bb_lk_exchange<br>
<br>
###################################################################<br>
# Mutation function 1.<br>
###################################################################<br>
<br>
mutation_func; similar_bb;<br>
database="/home/username/aldehydes_3f"<br>
<br>
###################################################################<br>
# Mutation function 2.<br>
###################################################################<br>
<br>
mutation_func; similar_lk;<br>
database="/home/username/amines_2f"<br>
<br>
###################################################################<br>
# When carrying mutations, chance that a given mutation function will be used.<br>
###################################################################<br>
<br>
mutation_weights=[1/4,3/4]<br>
<br>
###################################################################<br>
# Optimization function.<br>
###################################################################<br>
<br>
opt_func; macromodel_cage_opt;<br>
macromodel_path="/home/username/program_files/schrodinger2016-3"<br>
<br>
###################################################################<br>
# Fitness function.<br>
###################################################################<br>
<br>
fitness_func; cage; target_cavity=8; coeffs=[1,1,5,0,0];<br>
energy_params={"key":("macromodel", 16, "/home/username/schrodinger2016-3")}<br>
<br>
###################################################################<br>
# Normalization function.<br>
###################################################################<br>
<br>
normalization_func; carrots_and_sticks; carrot_coeffs=[1]; stick_coeffs=[1,1,1,1];<br>
carrot_exponents=[1]; stick_exponents=[1,1,1,1]<br>
<br>
###################################################################<br>
# Number of generations to create.<br>
###################################################################<br>
<br>
num_generations=10<br>
<br>
###################################################################<br>
# Number of mutation operations to perform each generation.<br>
###################################################################<br>
<br>
num_mutations=10<br>
<br>
###################################################################<br>
# Number of crossover operations to perform each generation.<br>
###################################################################<br>
<br>
num_crossovers=15<br>
<br>
###################################################################<br>
# Size of the population.<br>
###################################################################<br>
<br>
pop_size=20
    </code>
</p>
    <p>
        The first command,
        <code>
            init_func; init_random_cages;<br>
            bb_db="/home/username/aldehydes_3f";<br>
            lk_db="/home/username/amines_2f";<br>
            topologies=[FourPlusSix, EightPlusTwelve]
        </code>

        has the keyword <span class="value">init_func</span>, which  means that
        it defines the initialization function
        for the GA population. The initialization function is called
        <span class="value">init_random_cages</span>. This function
        creates a population consisting of randomly assembled porous "cage"
        molecules. The
         function
        takes the parameter <span class="value">bb_db</span> which receives a
        string. The string is the  path of  a directory which holds monomers
        used for constructing the cages. The
        parameter <span class="value">lk_db</span> has the same role. The
        parameter <span class="value">topologies</span> requires a list. The
         list contains the names of cage topologies defined within
        MMEA.
    </p><p>
        The second command,
        <code>
            generational_select_func; stochastic_sampling; use_rank=True
        </code>
        defines which function is to select members of
        successive generations. The function used to do this is
        <span class="value">stochastic_sampling</span> and the
        <span class="value">use_rank</span> parameter indicates that the
        inidividuals should be selected based on their rank in their population
        rather than their fitness.
    </p><p>
        The third command,
        <code>
            parent_select_func; crossover_roulette
        </code>
        defines which function is to select parents when crossover operations
        are performed. This function takes no parameters.
    </p><p>
        The fourth command,
        <code>
mutant_select_func; stochastic_sampling; duplicates=True
        </code>
        defines which function is to select parents when mutation operations
        are performed. The parameter <span class="value">duplicates</span>
        indicates that a molecule can be selected more than once.
    </p><p>
        The fifth command,
        <code>
crossover_func; bb_lk_exchange
        </code>
        defines the function which performs the crossover operation. In this case
        the building block and linkers of the two parents are exchanged to create
        the "offspring". Again, no parameters here.
    <p>
        The sixth command,
        <code>
        mutation_func; similar_bb;
        database="/home/username/aldehydes_3f"
        </code>
        defines the function which performs the mutation operation. In this
        case the function <span class="value">similar_bb</span>. The seventh
        commands also defines a mutation operation.
    </p>
    <p>
        The eight command,
        <code>
            mutation_weights=[1/4, 3/4]
        </code>
        Says that when a mutation operation is to be performed, the first
        mutation function defined in the input file should be selected with a
        probability of 0.25 and the second with a probability of 0.75.
    </p><p>
        The ninth command,
        <code>
            opt_func; macromodel_cage_opt;<br>
            macromodel_path="/home/username/program_files/schrodinger2016-3"
        </code>
        defines the optimization function which is used to optimize the geometry
        of all generated molecules. The <span class="value">macromodel_path</span>
        parameter holds the path where the MacroModel program is installed, as
        this function uses it to perform the optimizations. Yep, you're going
        need a MacroModel license to use this one.
    </p><p>
        The tenth command,
        <code>
            fitness_func; cage; target_cavity=8; coeffs=[1,1,5,0,0];<br>
            energy_params={'energy_func': <br>
            &emsp;&emsp;&emsp;&emsp;FunctionData('macromodel', <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;forcefield=16, <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;macromodel_path='/home/username/schrodinger2016-3')}
        </code>
        defines the fitness function of your GA. The <span class="value">cage</span>
        fitness function is used for evaluating porous "cage" molecules.
    Alternatives exist of course, depening on what kinds of molecules you want
    MMEA to generate. Notice the <span class="value">energy_params</span>
    parameter. It looks a little confusing. However, by breaking it down you will
    see that the parameter's value is just a Python dictionary as denoted by the
    curly brackets, <span class="value">{}</span>. The dictionary holds one key : value pair.
    The key in this case is the string <span class="value">'energy_func'</span>.
    The value associated with the key is a <span class="value">FunctionData</span>
    object. This is a type used by MMEA to describe functions. The name of the
    function is <span class="value">'macromodel'</span> and it takes the
    parameter <span class="value">forcefield</span> which is to be set to
    <span class="value">16</span>. It also takes the parameter
    <span class="value">macromodel_path</span> which again points to the
    MacroModel installation directory. All this is doing is telling the fitness function
    to use a specific energy function when working out the molecular energies.
</p><p>
    The eleventh command,
    <code>
        normalization_func; carrots_and_sticks; carrot_coeffs=[1]; stick_coeffs=[1,1,1,1];<br>
        carrot_exponents=[1]; stick_exponents=[1,1,1,1]
    </code>
    defines the normalization used for normalizing the fitness values
    of the population. In this case the
    <span class="value">carrots_and_sticks</span> function is used
    for normalizing the values. What it does is explained in the
    documentation (try the <span class="value">-h</span> option).
</p><p>
    The important point here is that some fitness functions may
    require certain normalization functions for the GA to run
    properly. In this case, <span class="value">cage</span>
    always requires that <span class="value">carrots_and_sticks</span>
    is defined in the input file. If a fitness function requires
    a given normalizatoin function, it should be specified in its
    documentation. The reverse is true as well. Some normalization
    functions may need specific fitness functions to work properly. However
    less restrive combinations may exist as well.

</p><p class="wide">
    The twelveth command,
    <code>
        num_generations=10
    </code>
    tells MMEA that it should stop after creating <span class="value">10</span> generations of molecules.

</p><p class="wide">
    The thirteenth command,
    <code>
        num_mutations=10
    </code>
    tells MMEA that it should carry out <span class="value">10</span> mutation operations each generation.

</p><p class="wide">
    The fourteenth command,
    <code>
        num_crossovers=15
    </code>
    tells MMEA that it should carry out <span class="value">15</span> crossover operations each generation.
</p><p class="wide">
        The fifteenth command,
        <code>
            pop_size=20
        </code>
        tells MMEA that the population's size should be <span class="value">20</span>.
</p>
        <h1>Running MMEA</h1>
    <h2>From the command line.</h2>
    <p>
    Using the console make sure you are in the directory containing MMEA (not in MMEA itself).
    Run the command,
    <code class="mmea_output">
        python -m MMEA input_file
    </code>

    where <span class="value">input_file</span> is the path to your input file.
</p>

    <h1>Output</h1>
    <p>
    While working MMEA will create a directory called <b>output</b>. Once the
    GA has finished a new folder called <b>old_output</b> will be created and
    your <b>output</b> folder will be placed inside. If you run multiple GA runs
    each succesive <b>output</b> file will be placed in the <b>old_output</b>
    folder and labelled from <b>0</b> upwards.
</p>
    <h1>MMEA as a Library</h1>
  </body>
</html>
